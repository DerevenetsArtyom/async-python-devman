9 час 40 мин 

ШАГ 4
# она нужна, чтобы связать две корутины.
# Одна меняет кадры анимации (animate_spaceship),
# другая их отрисовывает и обрабатывает read_control (run_spaceship).
# для отрисовки 2-a вызывает draw_frame и передает ей аргумент — текущий кадр.

'''
async def animate_spaceship():
    global spaceship_frame
    ...
    spaceship_frame = frame1
    ...
    spaceship_frame = frame2
    ...

async def run_spaceship():
    ...
    controls = read_controls()
    row, column = ...
    draw_frame(canvas, row, column, spaceship_frame)
    ...
'''


* curses умеет накапливать ввод. 
read_controls считывает все из буфера и может вернуть сразу два ненулевых 
значения — движение по горизонтали и по вертикали.
Получится диагональ. См. код def read_controls


* Никак не приходит на ум как сделать экспоненциальное увеличение мусора от времени в 11 задании. 
У нас же в coroutines должна быть только одна корутина run_asteroid_field?

Вычисли продолжительность игры по timestamp, разбей на 30-сек интервалы и для 
каждого добавь свой набор параметров для генерации мусора
первые 30 сек — нет мусора
вторые 30 сек — мусор появляется каждые 5 сек
третьи 30 сек...
ближе к 5 минутам мусора будет так много, что нет смысла наращивать дальше



* hitted_obstacles — новый список с препятствиями, по которым попали выстрелы
Как бы понятно что он глобальный, но везде пишете заранее, что глобальный список, а тут нету.

- Ну как бэ последние шаги урока. Пора бы уже :)
Ну и его не обязательно делать глобальным, можно передавать аргументом

Вот тут у нас же obstacles глобальный и я не особо понял в какую функцию это перенести и я просто засунул в coroutines. Работает так же, как и на гифке в уроке, можно же?
- Так и задумано


* Теперь hitted_obstacles это глобальный список, в который мы будем добавлять мусор, 
в который мы попали при этом удалив его из obstacles?
А потом проверять есть ли мусор в этом списке для дальнейшей прорисовки?
Жизни у объекта теперь тоже не нужны? 
Если в объект попали, то брейкнуть луп у fly_garbage?
 - Брейкнуть корутину. В остальном да, так


* Как только попадает снаряд в мусор, то сразу записывается в hitted_obstacles. 
В корутине fly_garbage идет проверка есть ли этот мусор в hitted_obstacles. 
Если есть, то делает на него await explode(...). 
В блоке finally всегда удаляет его в из обоих листов. Но вот в чем проблема. 
У меня как я стреляю в 1 мусор, взрываются сразу все, 
но только один попадает на время в hitted. В чем может быть проблема?
P.S. Проблему решил. Никогда не думал, что это может быть из-за того, 
что в классе Obstacle стоит декоратор @dataclass, 
а полей в нем нету с переменными, только конструктор.



* Урок второй по условиям задачи корутина run_spaceship управляет положением корабля и рисует его на экране. 
Но меня напрягает один момент, я это заметил еще в первом уроке - 
стоит добавить туда вызов read_controls(canvas), как анимация коробля начинает подтормаживать, 
при этом на гифках к урокам я такого не замечаю. 
Может стоит завести глобальную переменную controls (коллекция) и туда кидать 
считанные нажатия клавиш отдельной корутиной, 
а в run_spaceship к ней обращаться и реагировать если там что-то есть, как думаете?

Почти все сдают с этим багом. Во втором уроке он встает в полный рост и его уже обязательно чинить

